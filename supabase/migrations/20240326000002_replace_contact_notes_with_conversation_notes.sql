-- Drop the old contact_notes table
DROP TABLE IF EXISTS contact_notes;

-- Create the new conversation_notes table
CREATE TABLE conversation_notes (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  conversation_id bigint NOT NULL,
  note text NOT NULL,
  created_by uuid REFERENCES auth.users(id) NOT NULL,
  created_at timestamp with time zone DEFAULT now() NOT NULL,
  updated_at timestamp with time zone DEFAULT now() NOT NULL,
  archived boolean DEFAULT false NOT NULL,
  archived_by uuid REFERENCES auth.users(id) NULL,
  archived_at timestamp with time zone NULL,
  
  CONSTRAINT archive_consistency CHECK (
    (archived = false AND archived_by IS NULL AND archived_at IS NULL) OR
    (archived = true AND archived_by IS NOT NULL AND archived_at IS NOT NULL)
  )
);

-- Indexes for conversation_notes
CREATE INDEX conversation_notes_conversation_id_idx ON public.conversation_notes USING btree (conversation_id);
CREATE INDEX conversation_notes_created_by_idx ON public.conversation_notes USING btree (created_by);
CREATE INDEX conversation_notes_archived_idx ON public.conversation_notes USING btree (archived);

-- RLS for conversation_notes
ALTER TABLE conversation_notes ENABLE ROW LEVEL SECURITY;

-- Policies for conversation_notes
CREATE POLICY "Users can view conversation notes" ON conversation_notes
FOR SELECT USING (
  EXISTS (
    SELECT 1 
    FROM workspace_access wa
    WHERE wa.shared_with_user_id = auth.uid()
  )
);

CREATE POLICY "Users can create conversation notes" ON conversation_notes
FOR INSERT WITH CHECK (
  EXISTS (
    SELECT 1 
    FROM workspace_access wa
    WHERE wa.shared_with_user_id = auth.uid()
    AND wa.access_type = 'edit'
  )
);

CREATE POLICY "Users can update their own notes" ON conversation_notes
FOR UPDATE USING (
  created_by = auth.uid() AND
  EXISTS (
    SELECT 1 
    FROM workspace_access wa
    WHERE wa.shared_with_user_id = auth.uid()
    AND wa.access_type = 'edit'
  )
);

COMMENT ON TABLE conversation_notes IS 'Notes associated with conversations.
Each note entry contains:
1. The note text
2. Reference to the conversation
3. Standard audit fields (created_by, created_at, updated_at)
4. Soft delete capability (archived, archived_by, archived_at)';

-- Drop existing foreign key constraint if any exists
DO $$ BEGIN
    IF EXISTS (
        SELECT 1 
        FROM information_schema.table_constraints 
        WHERE constraint_name = 'conversation_notes_conversation_id_fkey'
        AND table_name = 'conversation_notes'
    ) THEN
        ALTER TABLE conversation_notes DROP CONSTRAINT conversation_notes_conversation_id_fkey;
    END IF;
END $$;

-- Drop existing index
DROP INDEX IF EXISTS conversation_notes_conversation_id_idx;

-- Alter the column type
ALTER TABLE conversation_notes 
    ALTER COLUMN conversation_id TYPE UUID 
    USING conversation_id::TEXT::UUID;

-- Add back the foreign key constraint
ALTER TABLE conversation_notes 
    ADD CONSTRAINT conversation_notes_conversation_id_fkey 
    FOREIGN KEY (conversation_id) 
    REFERENCES conversations(id) 
    ON DELETE CASCADE;

-- Recreate the index
CREATE INDEX conversation_notes_conversation_id_idx 
    ON conversation_notes(conversation_id); 